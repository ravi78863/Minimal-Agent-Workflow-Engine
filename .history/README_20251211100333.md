# Agent Workflow Engine (FastAPI)

This project is developed as part of the **AI Engineering Internship Backend Assignment**.  
It implements a minimal, clean, and extensible **agent workflow engine** inspired by LangGraph.  
The goal is to demonstrate strong fundamentals in:

- Python backend design  
- Async programming  
- Workflow/state management  
- API structuring with FastAPI  
- Clear logic flow (state → transitions → loops)

This is a **backend-only** project. No machine learning or frontend is required.

---

## 1. Assignment Overview

The assignment requires building a small workflow engine capable of:

- Defining nodes (Python functions)
- Maintaining a shared state between nodes
- Connecting nodes using edges
- Supporting conditional branching
- Supporting looping (repeat a node until condition met)
- Executing workflows through FastAPI APIs

A clean and correct implementation matters more than the number of features.

---

## 2. What This Engine Supports

### ✔ Minimal Workflow / Graph Engine
- Each node is a Python function (tool).
- Nodes read and update a shared state dictionary.
- Edges define which node runs next.
- Supports:
  - Linear execution
  - Conditional routing
  - Looping based on state values
- Step-by-step execution logging.

### ✔ Tool Registry
A simple dictionary that stores all node functions:

```python
tools = {
    "split_text": split_text,
    "generate_summaries": generate_summaries,
    "merge_summaries": merge_summaries,
    "refine_summary": refine_summary
}
```

Nodes call tools by name, making the engine easy to extend.

### ✔ FastAPI Endpoints
| Endpoint | Description |
|----------|-------------|
| **POST /graph/create** | Create a workflow graph |
| **POST /graph/run** | Run an existing workflow |
| **GET /graph/state/{run_id}** | Check state of a workflow run |
| **GET /graph/example** | Returns the template summarization workflow |

Runs and graphs are stored in-memory for simplicity.

---

## 3. Implemented Workflow: Option B — Summarization + Refinement

This project implements **Option B** from the assignment.

A simple, rule‑based text summarization pipeline:

1. **Split Text into Chunks**  
   Breaks long text into manageable pieces.

2. **Generate Summaries**  
   Produces a short summary for each chunk (rule‑based truncation).

3. **Merge Summaries**  
   Combines them into one summary.

4. **Refine Summary**  
   Ensures final summary meets character limit.

5. **Stop Condition**  
   Workflow stops when:  
   `summary_length <= summary_char_limit`

This workflow demonstrates:

- Sequential processing
- State mutation
- Looping logic
- Clean node execution design

---

## 4. Project Structure

```
app/
│── main.py        # FastAPI entrypoint
│── engine.py      # Core workflow engine
│── models.py      # Pydantic models for graph + run input/output
│── store.py       # In-memory storage for graphs and runs
│── tools.py       # Tools + prebuilt example workflow (Option B)
README.md
```

---

## 5. How to Run the Project

### Step 1: Create a virtual environment
```bash
python3 -m venv venv
source venv/bin/activate
```

### Step 2: Install dependencies
```bash
pip install fastapi uvicorn
```

### Step 3: Start the FastAPI server
```bash
uvicorn app.main:app --reload
```

### Step 4: Open API docs  
Go to:
```
http://127.0.0.1:8000/docs
```

---

## 6. Testing the Workflow

### 1. Get Example Graph
```
GET /graph/example
```

### 2. Run Workflow
```json
{
  "graph_id": "YOUR_GRAPH_ID",
  "initial_state": {
    "text": "Your long text...",
    "max_chunk_size": 100,
    "summary_char_limit": 120
  }
}
```

### 3. Output Includes:
- Final state after workflow execution  
- Execution log (each node, tool used, state updates)  
- Run ID for state tracking  

---

## 7. How This Meets Assignment Requirements

### ✔ Minimal Workflow Engine  
State, nodes, transitions, branches, loops implemented.

### ✔ Tool Registry  
Extensible Python function registry included.

### ✔ FastAPI APIs  
Graph creation, execution, and state retrieval working end‑to‑end.

### ✔ Looping Logic  
Workflow stops only when conditions are met (summary length limit).

### ✔ Clean Code Structure  
Modules separated by responsibility (engine, tools, API, models, store).

---

## 8. Future Improvements

If more time were available, the following enhancements could be added:

### Engine
- Persistent storage (SQLite/Postgres)
- Support for parallel node execution
- DAG visualization

### API
- WebSocket streaming of logs
- Background task processing

### Workflow
- More advanced summarization logic (still rule‑based)
- Multiple workflow templates selectable via API

---

## 9. Final Notes

This project demonstrates a clean, practical, and extensible workflow engine aligned with the internship assignment requirements.  
The implementation is simple, readable, and easy to extend — focusing on correctness and structure over complexity.

